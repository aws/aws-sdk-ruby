# WARNING ABOUT GENERATED CODE
#
# This file is generated. See the contributing guide for more information:
# https://github.com/aws/aws-sdk-ruby/blob/version-3/CONTRIBUTING.md
#
# WARNING ABOUT GENERATED CODE

module Aws
  module Lambda
    module Types
      class AccountLimit
        include Seahorse::Client::DelegatorMethodsForResponse[AccountLimit]

        attr_accessor total_code_size: tLong

        attr_accessor code_size_unzipped: tLong

        attr_accessor code_size_zipped: tLong

        attr_accessor concurrent_executions: tInteger

        attr_accessor unreserved_concurrent_executions: tUnreservedConcurrentExecutions
      end
      class AccountUsage
        include Seahorse::Client::DelegatorMethodsForResponse[AccountUsage]

        attr_accessor total_code_size: tLong

        attr_accessor function_count: tLong
      end
      type tAction = ::String
      type tAddLayerVersionPermissionRequest = { action: tLayerPermissionAllowedAction, layer_name: tLayerName, principal: tLayerPermissionAllowedPrincipal, statement_id: tStatementId, version_number: tLayerVersionNumber, organization_id: tOrganizationId?, revision_id: tString? }
      class AddLayerVersionPermissionResponse
        include Seahorse::Client::DelegatorMethodsForResponse[AddLayerVersionPermissionResponse]

        attr_accessor statement: tString

        attr_accessor revision_id: tString
      end
      type tAddPermissionRequest = { action: tAction, function_name: tFunctionName, principal: tPrincipal, statement_id: tStatementId, event_source_token: tEventSourceToken?, function_url_auth_type: tFunctionUrlAuthType?, principal_org_id: tPrincipalOrgID?, qualifier: tQualifier?, revision_id: tString?, source_account: tSourceOwner?, source_arn: tArn? }
      class AddPermissionResponse
        include Seahorse::Client::DelegatorMethodsForResponse[AddPermissionResponse]

        attr_accessor statement: tString
      end
      type tAdditionalVersion = ::String
      type tAdditionalVersionWeights = ::Hash[tAdditionalVersion, tWeight]
      type tAlias = ::String
      class AliasConfiguration
        include Seahorse::Client::DelegatorMethodsForResponse[AliasConfiguration]

        attr_accessor alias_arn: tFunctionArn

        attr_accessor name: tAlias

        attr_accessor function_version: tVersion

        attr_accessor description: tDescription

        attr_accessor routing_config: AliasRoutingConfiguration

        attr_accessor revision_id: tString
      end
      type tAliasList_output = ::Array[AliasConfiguration]
      type tAliasRoutingConfiguration = { additional_version_weights: tAdditionalVersionWeights? }
      class AliasRoutingConfiguration
        include Seahorse::Client::DelegatorMethodsForResponse[AliasRoutingConfiguration]

        attr_accessor additional_version_weights: tAdditionalVersionWeights
      end
      type tAllowCredentials = bool
      type tAllowMethodsList = ::Array[tMethod]
      type tAllowOriginsList = ::Array[tOrigin]
      type tAllowedPublishers = { signing_profile_version_arns: tSigningProfileVersionArns }
      class AllowedPublishers
        include Seahorse::Client::DelegatorMethodsForResponse[AllowedPublishers]

        attr_accessor signing_profile_version_arns: tSigningProfileVersionArns
      end
      type tAmazonManagedKafkaEventSourceConfig = { consumer_group_id: tURI? }
      class AmazonManagedKafkaEventSourceConfig
        include Seahorse::Client::DelegatorMethodsForResponse[AmazonManagedKafkaEventSourceConfig]

        attr_accessor consumer_group_id: tURI
      end
      type tApplicationLogLevel = ("TRACE" | "DEBUG" | "INFO" | "WARN" | "ERROR" | "FATAL")
      type tArchitecture = ("x86_64" | "arm64")
      type tArchitecturesList = ::Array[tArchitecture]
      type tArn = ::String
      type tBatchSize = ::Integer
      type tBisectBatchOnFunctionError = bool
      type tBlob = ::String
      type tBlobStream = ::String
      type tBoolean = bool
      class CodeSigningConfig
        include Seahorse::Client::DelegatorMethodsForResponse[CodeSigningConfig]

        attr_accessor code_signing_config_id: tCodeSigningConfigId

        attr_accessor code_signing_config_arn: tCodeSigningConfigArn

        attr_accessor description: tDescription

        attr_accessor allowed_publishers: AllowedPublishers

        attr_accessor code_signing_policies: CodeSigningPolicies

        attr_accessor last_modified: tTimestamp
      end
      type tCodeSigningConfigArn = ::String
      type tCodeSigningConfigId = ::String
      type tCodeSigningConfigList_output = ::Array[CodeSigningConfig]
      type tCodeSigningPolicies = { untrusted_artifact_on_deployment: tCodeSigningPolicy? }
      class CodeSigningPolicies
        include Seahorse::Client::DelegatorMethodsForResponse[CodeSigningPolicies]

        attr_accessor untrusted_artifact_on_deployment: tCodeSigningPolicy
      end
      type tCodeSigningPolicy = ("Warn" | "Enforce")
      type tCollectionName = ::String
      type tCompatibleArchitectures = ::Array[tArchitecture]
      type tCompatibleRuntimes = ::Array[tRuntime]
      class Concurrency
        include Seahorse::Client::DelegatorMethodsForResponse[Concurrency]

        attr_accessor reserved_concurrent_executions: tReservedConcurrentExecutions
      end
      type tCors = { allow_credentials: tAllowCredentials?, allow_headers: tHeadersList?, allow_methods: tAllowMethodsList?, allow_origins: tAllowOriginsList?, expose_headers: tHeadersList?, max_age: tMaxAge? }
      class Cors
        include Seahorse::Client::DelegatorMethodsForResponse[Cors]

        attr_accessor allow_credentials: tAllowCredentials

        attr_accessor allow_headers: tHeadersList

        attr_accessor allow_methods: tAllowMethodsList

        attr_accessor allow_origins: tAllowOriginsList

        attr_accessor expose_headers: tHeadersList

        attr_accessor max_age: tMaxAge
      end
      type tCreateAliasRequest = { function_name: tFunctionName, function_version: tVersion, name: tAlias, description: tDescription?, routing_config: tAliasRoutingConfiguration? }
      type tCreateCodeSigningConfigRequest = { allowed_publishers: tAllowedPublishers, code_signing_policies: tCodeSigningPolicies?, description: tDescription? }
      class CreateCodeSigningConfigResponse
        include Seahorse::Client::DelegatorMethodsForResponse[CreateCodeSigningConfigResponse]

        attr_accessor code_signing_config: CodeSigningConfig
      end
      type tCreateEventSourceMappingRequest = { function_name: tFunctionName, amazon_managed_kafka_event_source_config: tAmazonManagedKafkaEventSourceConfig?, batch_size: tBatchSize?, bisect_batch_on_function_error: tBisectBatchOnFunctionError?, destination_config: tDestinationConfig?, document_db_event_source_config: tDocumentDBEventSourceConfig?, enabled: tEnabled?, event_source_arn: tArn?, filter_criteria: tFilterCriteria?, function_response_types: tFunctionResponseTypeList?, maximum_batching_window_in_seconds: tMaximumBatchingWindowInSeconds?, maximum_record_age_in_seconds: tMaximumRecordAgeInSeconds?, maximum_retry_attempts: tMaximumRetryAttemptsEventSourceMapping?, parallelization_factor: tParallelizationFactor?, queues: tQueues?, scaling_config: tScalingConfig?, self_managed_event_source: tSelfManagedEventSource?, self_managed_kafka_event_source_config: tSelfManagedKafkaEventSourceConfig?, source_access_configurations: tSourceAccessConfigurations_input?, starting_position: tEventSourcePosition?, starting_position_timestamp: tDate?, topics: tTopics?, tumbling_window_in_seconds: tTumblingWindowInSeconds? }
      type tCreateFunctionRequest = { code: tFunctionCode, function_name: tFunctionName, role: tRoleArn, architectures: tArchitecturesList?, code_signing_config_arn: tCodeSigningConfigArn?, dead_letter_config: tDeadLetterConfig?, description: tDescription?, environment: tEnvironment?, ephemeral_storage: tEphemeralStorage?, file_system_configs: tFileSystemConfigList_input?, handler: tHandler?, image_config: tImageConfig?, kms_key_arn: tKMSKeyArn?, layers: tLayerList?, logging_config: tLoggingConfig?, memory_size: tMemorySize?, package_type: tPackageType?, publish: tBoolean?, runtime: tRuntime?, snap_start: tSnapStart?, tags: tTags?, timeout: tTimeout?, tracing_config: tTracingConfig?, vpc_config: tVpcConfig? }
      type tCreateFunctionUrlConfigRequest = { auth_type: tFunctionUrlAuthType, function_name: tFunctionName, cors: tCors?, invoke_mode: tInvokeMode?, qualifier: tFunctionUrlQualifier? }
      class CreateFunctionUrlConfigResponse
        include Seahorse::Client::DelegatorMethodsForResponse[CreateFunctionUrlConfigResponse]

        attr_accessor function_url: tFunctionUrl

        attr_accessor function_arn: tFunctionArn

        attr_accessor auth_type: tFunctionUrlAuthType

        attr_accessor cors: Cors

        attr_accessor creation_time: tTimestamp

        attr_accessor invoke_mode: tInvokeMode
      end
      type tDatabaseName = ::String
      type tDate = ::Time
      type tDeadLetterConfig = { target_arn: tResourceArn? }
      class DeadLetterConfig
        include Seahorse::Client::DelegatorMethodsForResponse[DeadLetterConfig]

        attr_accessor target_arn: tResourceArn
      end
      type tDeleteAliasRequest = { function_name: tFunctionName, name: tAlias }
      type tDeleteCodeSigningConfigRequest = { code_signing_config_arn: tCodeSigningConfigArn }
      class DeleteCodeSigningConfigResponse < ::Aws::EmptyStructure
      end
      type tDeleteEventSourceMappingRequest = { uuid: tString }
      type tDeleteFunctionCodeSigningConfigRequest = { function_name: tFunctionName }
      type tDeleteFunctionConcurrencyRequest = { function_name: tFunctionName }
      type tDeleteFunctionEventInvokeConfigRequest = { function_name: tFunctionName, qualifier: tQualifier? }
      type tDeleteFunctionRequest = { function_name: tFunctionName, qualifier: tQualifier? }
      type tDeleteFunctionUrlConfigRequest = { function_name: tFunctionName, qualifier: tFunctionUrlQualifier? }
      type tDeleteLayerVersionRequest = { layer_name: tLayerName, version_number: tLayerVersionNumber }
      type tDeleteProvisionedConcurrencyConfigRequest = { function_name: tFunctionName, qualifier: tQualifier }
      type tDescription = ::String
      type tDestinationArn = ::String
      type tDestinationConfig = { on_failure: tOnFailure?, on_success: tOnSuccess? }
      class DestinationConfig
        include Seahorse::Client::DelegatorMethodsForResponse[DestinationConfig]

        attr_accessor on_success: OnSuccess

        attr_accessor on_failure: OnFailure
      end
      type tDocumentDBEventSourceConfig = { collection_name: tCollectionName?, database_name: tDatabaseName?, full_document: tFullDocument? }
      class DocumentDBEventSourceConfig
        include Seahorse::Client::DelegatorMethodsForResponse[DocumentDBEventSourceConfig]

        attr_accessor database_name: tDatabaseName

        attr_accessor collection_name: tCollectionName

        attr_accessor full_document: tFullDocument
      end
      type tEnabled = bool
      type tEndPointType = ("KAFKA_BOOTSTRAP_SERVERS")
      type tEndpoint = ::String
      type tEndpointLists = ::Array[tEndpoint]
      type tEndpoints = ::Hash[tEndPointType, tEndpointLists]
      type tEnvironment = { variables: tEnvironmentVariables? }
      class EnvironmentError
        include Seahorse::Client::DelegatorMethodsForResponse[EnvironmentError]

        attr_accessor error_code: tString

        attr_accessor message: tSensitiveString
      end
      class EnvironmentResponse
        include Seahorse::Client::DelegatorMethodsForResponse[EnvironmentResponse]

        attr_accessor variables: tEnvironmentVariables

        attr_accessor error: EnvironmentError
      end
      type tEnvironmentVariableName = ::String
      type tEnvironmentVariableValue = ::String
      type tEnvironmentVariables = ::Hash[tEnvironmentVariableName, tEnvironmentVariableValue]
      type tEphemeralStorage = { size: tEphemeralStorageSize }
      class EphemeralStorage
        include Seahorse::Client::DelegatorMethodsForResponse[EphemeralStorage]

        attr_accessor size: tEphemeralStorageSize
      end
      type tEphemeralStorageSize = ::Integer
      class EventSourceMappingConfiguration
        include Seahorse::Client::DelegatorMethodsForResponse[EventSourceMappingConfiguration]

        attr_accessor uuid: tString

        attr_accessor starting_position: tEventSourcePosition

        attr_accessor starting_position_timestamp: tDate

        attr_accessor batch_size: tBatchSize

        attr_accessor maximum_batching_window_in_seconds: tMaximumBatchingWindowInSeconds

        attr_accessor parallelization_factor: tParallelizationFactor

        attr_accessor event_source_arn: tArn

        attr_accessor filter_criteria: FilterCriteria

        attr_accessor function_arn: tFunctionArn

        attr_accessor last_modified: tDate

        attr_accessor last_processing_result: tString

        attr_accessor state: tString

        attr_accessor state_transition_reason: tString

        attr_accessor destination_config: DestinationConfig

        attr_accessor topics: tTopics

        attr_accessor queues: tQueues

        attr_accessor source_access_configurations: tSourceAccessConfigurations_output

        attr_accessor self_managed_event_source: SelfManagedEventSource

        attr_accessor maximum_record_age_in_seconds: tMaximumRecordAgeInSeconds

        attr_accessor bisect_batch_on_function_error: tBisectBatchOnFunctionError

        attr_accessor maximum_retry_attempts: tMaximumRetryAttemptsEventSourceMapping

        attr_accessor tumbling_window_in_seconds: tTumblingWindowInSeconds

        attr_accessor function_response_types: tFunctionResponseTypeList

        attr_accessor amazon_managed_kafka_event_source_config: AmazonManagedKafkaEventSourceConfig

        attr_accessor self_managed_kafka_event_source_config: SelfManagedKafkaEventSourceConfig

        attr_accessor scaling_config: ScalingConfig

        attr_accessor document_db_event_source_config: DocumentDBEventSourceConfig
      end
      type tEventSourceMappingsList_output = ::Array[EventSourceMappingConfiguration]
      type tEventSourcePosition = ("TRIM_HORIZON" | "LATEST" | "AT_TIMESTAMP")
      type tEventSourceToken = ::String
      type tFileSystemArn = ::String
      type tFileSystemConfig = { arn: tFileSystemArn, local_mount_path: tLocalMountPath }
      class FileSystemConfig
        include Seahorse::Client::DelegatorMethodsForResponse[FileSystemConfig]

        attr_accessor arn: tFileSystemArn

        attr_accessor local_mount_path: tLocalMountPath
      end
      type tFileSystemConfigList_input = ::Array[tFileSystemConfig]
      type tFileSystemConfigList_output = ::Array[FileSystemConfig]
      type tFilter = { pattern: tPattern? }
      class Filter
        include Seahorse::Client::DelegatorMethodsForResponse[Filter]

        attr_accessor pattern: tPattern
      end
      type tFilterCriteria = { filters: tFilterList_input? }
      class FilterCriteria
        include Seahorse::Client::DelegatorMethodsForResponse[FilterCriteria]

        attr_accessor filters: tFilterList_output
      end
      type tFilterList_input = ::Array[tFilter]
      type tFilterList_output = ::Array[Filter]
      type tFullDocument = ("UpdateLookup" | "Default")
      type tFunctionArn = ::String
      type tFunctionArnList = ::Array[tFunctionArn]
      type tFunctionCode = { image_uri: tString?, s3_bucket: tS3Bucket?, s3_key: tS3Key?, s3_object_version: tS3ObjectVersion?, zip_file: tBlob? }
      class FunctionCodeLocation
        include Seahorse::Client::DelegatorMethodsForResponse[FunctionCodeLocation]

        attr_accessor repository_type: tString

        attr_accessor location: tString

        attr_accessor image_uri: tString

        attr_accessor resolved_image_uri: tString
      end
      class FunctionConfiguration
        include Seahorse::Client::DelegatorMethodsForResponse[FunctionConfiguration]

        attr_accessor function_name: tNamespacedFunctionName

        attr_accessor function_arn: tNameSpacedFunctionArn

        attr_accessor runtime: tRuntime

        attr_accessor role: tRoleArn

        attr_accessor handler: tHandler

        attr_accessor code_size: tLong

        attr_accessor description: tDescription

        attr_accessor timeout: tTimeout

        attr_accessor memory_size: tMemorySize

        attr_accessor last_modified: tTimestamp

        attr_accessor code_sha_256: tString

        attr_accessor version: tVersion

        attr_accessor vpc_config: VpcConfigResponse

        attr_accessor dead_letter_config: DeadLetterConfig

        attr_accessor environment: EnvironmentResponse

        attr_accessor kms_key_arn: tKMSKeyArn

        attr_accessor tracing_config: TracingConfigResponse

        attr_accessor master_arn: tFunctionArn

        attr_accessor revision_id: tString

        attr_accessor layers: tLayersReferenceList

        attr_accessor state: tState

        attr_accessor state_reason: tStateReason

        attr_accessor state_reason_code: tStateReasonCode

        attr_accessor last_update_status: tLastUpdateStatus

        attr_accessor last_update_status_reason: tLastUpdateStatusReason

        attr_accessor last_update_status_reason_code: tLastUpdateStatusReasonCode

        attr_accessor file_system_configs: tFileSystemConfigList_output

        attr_accessor package_type: tPackageType

        attr_accessor image_config_response: ImageConfigResponse

        attr_accessor signing_profile_version_arn: tArn

        attr_accessor signing_job_arn: tArn

        attr_accessor architectures: tArchitecturesList

        attr_accessor ephemeral_storage: EphemeralStorage

        attr_accessor snap_start: SnapStartResponse

        attr_accessor runtime_version_config: RuntimeVersionConfig

        attr_accessor logging_config: LoggingConfig
      end
      class FunctionEventInvokeConfig
        include Seahorse::Client::DelegatorMethodsForResponse[FunctionEventInvokeConfig]

        attr_accessor last_modified: tDate

        attr_accessor function_arn: tFunctionArn

        attr_accessor maximum_retry_attempts: tMaximumRetryAttempts

        attr_accessor maximum_event_age_in_seconds: tMaximumEventAgeInSeconds

        attr_accessor destination_config: DestinationConfig
      end
      type tFunctionEventInvokeConfigList_output = ::Array[FunctionEventInvokeConfig]
      type tFunctionList_output = ::Array[FunctionConfiguration]
      type tFunctionName = ::String
      type tFunctionResponseType = ("ReportBatchItemFailures")
      type tFunctionResponseTypeList = ::Array[tFunctionResponseType]
      type tFunctionUrl = ::String
      type tFunctionUrlAuthType = ("NONE" | "AWS_IAM")
      class FunctionUrlConfig
        include Seahorse::Client::DelegatorMethodsForResponse[FunctionUrlConfig]

        attr_accessor function_url: tFunctionUrl

        attr_accessor function_arn: tFunctionArn

        attr_accessor creation_time: tTimestamp

        attr_accessor last_modified_time: tTimestamp

        attr_accessor cors: Cors

        attr_accessor auth_type: tFunctionUrlAuthType

        attr_accessor invoke_mode: tInvokeMode
      end
      type tFunctionUrlConfigList = ::Array[FunctionUrlConfig]
      type tFunctionUrlQualifier = ::String
      type tFunctionVersion = ("ALL")
      type tGetAccountSettingsRequest = ::Hash[untyped, untyped]
      class GetAccountSettingsResponse
        include Seahorse::Client::DelegatorMethodsForResponse[GetAccountSettingsResponse]

        attr_accessor account_limit: AccountLimit

        attr_accessor account_usage: AccountUsage
      end
      type tGetAliasRequest = { function_name: tFunctionName, name: tAlias }
      type tGetCodeSigningConfigRequest = { code_signing_config_arn: tCodeSigningConfigArn }
      class GetCodeSigningConfigResponse
        include Seahorse::Client::DelegatorMethodsForResponse[GetCodeSigningConfigResponse]

        attr_accessor code_signing_config: CodeSigningConfig
      end
      type tGetEventSourceMappingRequest = { uuid: tString }
      type tGetFunctionCodeSigningConfigRequest = { function_name: tFunctionName }
      class GetFunctionCodeSigningConfigResponse
        include Seahorse::Client::DelegatorMethodsForResponse[GetFunctionCodeSigningConfigResponse]

        attr_accessor code_signing_config_arn: tCodeSigningConfigArn

        attr_accessor function_name: tFunctionName
      end
      type tGetFunctionConcurrencyRequest = { function_name: tFunctionName }
      class GetFunctionConcurrencyResponse
        include Seahorse::Client::DelegatorMethodsForResponse[GetFunctionConcurrencyResponse]

        attr_accessor reserved_concurrent_executions: tReservedConcurrentExecutions
      end
      type tGetFunctionConfigurationRequest = { function_name: tNamespacedFunctionName, qualifier: tQualifier? }
      type tGetFunctionEventInvokeConfigRequest = { function_name: tFunctionName, qualifier: tQualifier? }
      type tGetFunctionRequest = { function_name: tNamespacedFunctionName, qualifier: tQualifier? }
      class GetFunctionResponse
        include Seahorse::Client::DelegatorMethodsForResponse[GetFunctionResponse]

        attr_accessor configuration: FunctionConfiguration

        attr_accessor code: FunctionCodeLocation

        attr_accessor tags: tTags

        attr_accessor concurrency: Concurrency
      end
      type tGetFunctionUrlConfigRequest = { function_name: tFunctionName, qualifier: tFunctionUrlQualifier? }
      class GetFunctionUrlConfigResponse
        include Seahorse::Client::DelegatorMethodsForResponse[GetFunctionUrlConfigResponse]

        attr_accessor function_url: tFunctionUrl

        attr_accessor function_arn: tFunctionArn

        attr_accessor auth_type: tFunctionUrlAuthType

        attr_accessor cors: Cors

        attr_accessor creation_time: tTimestamp

        attr_accessor last_modified_time: tTimestamp

        attr_accessor invoke_mode: tInvokeMode
      end
      type tGetLayerVersionByArnRequest = { arn: tLayerVersionArn }
      type tGetLayerVersionPolicyRequest = { layer_name: tLayerName, version_number: tLayerVersionNumber }
      class GetLayerVersionPolicyResponse
        include Seahorse::Client::DelegatorMethodsForResponse[GetLayerVersionPolicyResponse]

        attr_accessor policy: tString

        attr_accessor revision_id: tString
      end
      type tGetLayerVersionRequest = { layer_name: tLayerName, version_number: tLayerVersionNumber }
      class GetLayerVersionResponse
        include Seahorse::Client::DelegatorMethodsForResponse[GetLayerVersionResponse]

        attr_accessor content: LayerVersionContentOutput

        attr_accessor layer_arn: tLayerArn

        attr_accessor layer_version_arn: tLayerVersionArn

        attr_accessor description: tDescription

        attr_accessor created_date: tTimestamp

        attr_accessor version: tLayerVersionNumber

        attr_accessor compatible_runtimes: tCompatibleRuntimes

        attr_accessor license_info: tLicenseInfo

        attr_accessor compatible_architectures: tCompatibleArchitectures
      end
      type tGetPolicyRequest = { function_name: tNamespacedFunctionName, qualifier: tQualifier? }
      class GetPolicyResponse
        include Seahorse::Client::DelegatorMethodsForResponse[GetPolicyResponse]

        attr_accessor policy: tString

        attr_accessor revision_id: tString
      end
      type tGetProvisionedConcurrencyConfigRequest = { function_name: tFunctionName, qualifier: tQualifier }
      class GetProvisionedConcurrencyConfigResponse
        include Seahorse::Client::DelegatorMethodsForResponse[GetProvisionedConcurrencyConfigResponse]

        attr_accessor requested_provisioned_concurrent_executions: tPositiveInteger

        attr_accessor available_provisioned_concurrent_executions: tNonNegativeInteger

        attr_accessor allocated_provisioned_concurrent_executions: tNonNegativeInteger

        attr_accessor status: tProvisionedConcurrencyStatusEnum

        attr_accessor status_reason: tString

        attr_accessor last_modified: tTimestamp
      end
      type tGetRuntimeManagementConfigRequest = { function_name: tNamespacedFunctionName, qualifier: tQualifier? }
      class GetRuntimeManagementConfigResponse
        include Seahorse::Client::DelegatorMethodsForResponse[GetRuntimeManagementConfigResponse]

        attr_accessor update_runtime_on: tUpdateRuntimeOn

        attr_accessor runtime_version_arn: tRuntimeVersionArn

        attr_accessor function_arn: tNameSpacedFunctionArn
      end
      type tHandler = ::String
      type tHeader = ::String
      type tHeadersList = ::Array[tHeader]
      type tHttpStatus = ::Integer
      type tImageConfig = { command: tStringList?, entry_point: tStringList?, working_directory: tWorkingDirectory? }
      class ImageConfig
        include Seahorse::Client::DelegatorMethodsForResponse[ImageConfig]

        attr_accessor entry_point: tStringList

        attr_accessor command: tStringList

        attr_accessor working_directory: tWorkingDirectory
      end
      class ImageConfigError
        include Seahorse::Client::DelegatorMethodsForResponse[ImageConfigError]

        attr_accessor error_code: tString

        attr_accessor message: tSensitiveString
      end
      class ImageConfigResponse
        include Seahorse::Client::DelegatorMethodsForResponse[ImageConfigResponse]

        attr_accessor image_config: ImageConfig

        attr_accessor error: ImageConfigError
      end
      type tInteger = ::Integer
      type tInvocationRequest = { function_name: tNamespacedFunctionName, client_context: tString?, invocation_type: tInvocationType?, log_type: tLogType?, payload: tBlob?, qualifier: tQualifier? }
      class InvocationResponse
        include Seahorse::Client::DelegatorMethodsForResponse[InvocationResponse]

        attr_accessor status_code: tInteger

        attr_accessor function_error: tString

        attr_accessor log_result: tString

        attr_accessor payload: tBlob

        attr_accessor executed_version: tVersion
      end
      type tInvocationType = ("Event" | "RequestResponse" | "DryRun")
      type tInvokeAsyncRequest = { function_name: tNamespacedFunctionName, invoke_args: tBlobStream }
      class InvokeAsyncResponse
        include Seahorse::Client::DelegatorMethodsForResponse[InvokeAsyncResponse]

        attr_accessor status: tHttpStatus
      end
      type tInvokeMode = ("BUFFERED" | "RESPONSE_STREAM")
      class InvokeResponseStreamUpdate
        include Seahorse::Client::DelegatorMethodsForResponse[InvokeResponseStreamUpdate]

        attr_accessor payload: tBlob
      end
      class InvokeWithResponseStreamCompleteEvent
        include Seahorse::Client::DelegatorMethodsForResponse[InvokeWithResponseStreamCompleteEvent]

        attr_accessor error_code: tString

        attr_accessor error_details: tString

        attr_accessor log_result: tString
      end
      type tInvokeWithResponseStreamRequest = { function_name: tNamespacedFunctionName, client_context: tString?, invocation_type: tResponseStreamingInvocationType?, log_type: tLogType?, payload: tBlob?, qualifier: tQualifier? }
      class InvokeWithResponseStreamResponse
        include Seahorse::Client::DelegatorMethodsForResponse[InvokeWithResponseStreamResponse]

        attr_accessor status_code: tInteger

        attr_accessor executed_version: tVersion

        attr_accessor event_stream: InvokeWithResponseStreamResponseEvent

        attr_accessor response_stream_content_type: tString
      end
      class InvokeWithResponseStreamResponseEvent
        include Seahorse::Client::DelegatorMethodsForResponse[InvokeWithResponseStreamResponseEvent]

        attr_accessor payload_chunk: InvokeResponseStreamUpdate

        attr_accessor invoke_complete: InvokeWithResponseStreamCompleteEvent
      end
      type tKMSKeyArn = ::String
      type tLastUpdateStatus = ("Successful" | "Failed" | "InProgress")
      type tLastUpdateStatusReason = ::String
      type tLastUpdateStatusReasonCode = ("EniLimitExceeded" | "InsufficientRolePermissions" | "InvalidConfiguration" | "InternalError" | "SubnetOutOfIPAddresses" | "InvalidSubnet" | "InvalidSecurityGroup" | "ImageDeleted" | "ImageAccessDenied" | "InvalidImage" | "KMSKeyAccessDenied" | "KMSKeyNotFound" | "InvalidStateKMSKey" | "DisabledKMSKey" | "EFSIOError" | "EFSMountConnectivityError" | "EFSMountFailure" | "EFSMountTimeout" | "InvalidRuntime" | "InvalidZipFileException" | "FunctionError")
      class Layer
        include Seahorse::Client::DelegatorMethodsForResponse[Layer]

        attr_accessor arn: tLayerVersionArn

        attr_accessor code_size: tLong

        attr_accessor signing_profile_version_arn: tArn

        attr_accessor signing_job_arn: tArn
      end
      type tLayerArn = ::String
      type tLayerList = ::Array[tLayerVersionArn]
      type tLayerName = ::String
      type tLayerPermissionAllowedAction = ::String
      type tLayerPermissionAllowedPrincipal = ::String
      type tLayerVersionArn = ::String
      type tLayerVersionContentInput = { s3_bucket: tS3Bucket?, s3_key: tS3Key?, s3_object_version: tS3ObjectVersion?, zip_file: tBlob? }
      class LayerVersionContentOutput
        include Seahorse::Client::DelegatorMethodsForResponse[LayerVersionContentOutput]

        attr_accessor location: tString

        attr_accessor code_sha_256: tString

        attr_accessor code_size: tLong

        attr_accessor signing_profile_version_arn: tString

        attr_accessor signing_job_arn: tString
      end
      type tLayerVersionNumber = ::Integer
      type tLayerVersionsList_output = ::Array[LayerVersionsListItem]
      class LayerVersionsListItem
        include Seahorse::Client::DelegatorMethodsForResponse[LayerVersionsListItem]

        attr_accessor layer_version_arn: tLayerVersionArn

        attr_accessor version: tLayerVersionNumber

        attr_accessor description: tDescription

        attr_accessor created_date: tTimestamp

        attr_accessor compatible_runtimes: tCompatibleRuntimes

        attr_accessor license_info: tLicenseInfo

        attr_accessor compatible_architectures: tCompatibleArchitectures
      end
      type tLayersList = ::Array[LayersListItem]
      class LayersListItem
        include Seahorse::Client::DelegatorMethodsForResponse[LayersListItem]

        attr_accessor layer_name: tLayerName

        attr_accessor layer_arn: tLayerArn

        attr_accessor latest_matching_version: LayerVersionsListItem
      end
      type tLayersReferenceList = ::Array[Layer]
      type tLicenseInfo = ::String
      type tListAliasesRequest = { function_name: tFunctionName, function_version: tVersion?, marker: tString?, max_items: tMaxListItems? }
      class ListAliasesResponse
        include Seahorse::Client::DelegatorMethodsForResponse[ListAliasesResponse]

        attr_accessor next_marker: tString

        attr_accessor aliases: tAliasList_output
      end
      type tListCodeSigningConfigsRequest = { marker: tString?, max_items: tMaxListItems? }
      class ListCodeSigningConfigsResponse
        include Seahorse::Client::DelegatorMethodsForResponse[ListCodeSigningConfigsResponse]

        attr_accessor next_marker: tString

        attr_accessor code_signing_configs: tCodeSigningConfigList_output
      end
      type tListEventSourceMappingsRequest = { event_source_arn: tArn?, function_name: tFunctionName?, marker: tString?, max_items: tMaxListItems? }
      class ListEventSourceMappingsResponse
        include Seahorse::Client::DelegatorMethodsForResponse[ListEventSourceMappingsResponse]

        attr_accessor next_marker: tString

        attr_accessor event_source_mappings: tEventSourceMappingsList_output
      end
      type tListFunctionEventInvokeConfigsRequest = { function_name: tFunctionName, marker: tString?, max_items: tMaxFunctionEventInvokeConfigListItems? }
      class ListFunctionEventInvokeConfigsResponse
        include Seahorse::Client::DelegatorMethodsForResponse[ListFunctionEventInvokeConfigsResponse]

        attr_accessor function_event_invoke_configs: tFunctionEventInvokeConfigList_output

        attr_accessor next_marker: tString
      end
      type tListFunctionUrlConfigsRequest = { function_name: tFunctionName, marker: tString?, max_items: tMaxItems? }
      class ListFunctionUrlConfigsResponse
        include Seahorse::Client::DelegatorMethodsForResponse[ListFunctionUrlConfigsResponse]

        attr_accessor function_url_configs: tFunctionUrlConfigList

        attr_accessor next_marker: tString
      end
      type tListFunctionsByCodeSigningConfigRequest = { code_signing_config_arn: tCodeSigningConfigArn, marker: tString?, max_items: tMaxListItems? }
      class ListFunctionsByCodeSigningConfigResponse
        include Seahorse::Client::DelegatorMethodsForResponse[ListFunctionsByCodeSigningConfigResponse]

        attr_accessor next_marker: tString

        attr_accessor function_arns: tFunctionArnList
      end
      type tListFunctionsRequest = { function_version: tFunctionVersion?, marker: tString?, master_region: tMasterRegion?, max_items: tMaxListItems? }
      class ListFunctionsResponse
        include Seahorse::Client::DelegatorMethodsForResponse[ListFunctionsResponse]

        attr_accessor next_marker: tString

        attr_accessor functions: tFunctionList_output
      end
      type tListLayerVersionsRequest = { layer_name: tLayerName, compatible_architecture: tArchitecture?, compatible_runtime: tRuntime?, marker: tString?, max_items: tMaxLayerListItems? }
      class ListLayerVersionsResponse
        include Seahorse::Client::DelegatorMethodsForResponse[ListLayerVersionsResponse]

        attr_accessor next_marker: tString

        attr_accessor layer_versions: tLayerVersionsList_output
      end
      type tListLayersRequest = { compatible_architecture: tArchitecture?, compatible_runtime: tRuntime?, marker: tString?, max_items: tMaxLayerListItems? }
      class ListLayersResponse
        include Seahorse::Client::DelegatorMethodsForResponse[ListLayersResponse]

        attr_accessor next_marker: tString

        attr_accessor layers: tLayersList
      end
      type tListProvisionedConcurrencyConfigsRequest = { function_name: tFunctionName, marker: tString?, max_items: tMaxProvisionedConcurrencyConfigListItems? }
      class ListProvisionedConcurrencyConfigsResponse
        include Seahorse::Client::DelegatorMethodsForResponse[ListProvisionedConcurrencyConfigsResponse]

        attr_accessor provisioned_concurrency_configs: tProvisionedConcurrencyConfigList

        attr_accessor next_marker: tString
      end
      type tListTagsRequest = { resource: tFunctionArn }
      class ListTagsResponse
        include Seahorse::Client::DelegatorMethodsForResponse[ListTagsResponse]

        attr_accessor tags: tTags
      end
      type tListVersionsByFunctionRequest = { function_name: tNamespacedFunctionName, marker: tString?, max_items: tMaxListItems? }
      class ListVersionsByFunctionResponse
        include Seahorse::Client::DelegatorMethodsForResponse[ListVersionsByFunctionResponse]

        attr_accessor next_marker: tString

        attr_accessor versions: tFunctionList_output
      end
      type tLocalMountPath = ::String
      type tLogFormat = ("JSON" | "Text")
      type tLogGroup = ::String
      type tLogType = ("None" | "Tail")
      type tLoggingConfig = { application_log_level: tApplicationLogLevel?, log_format: tLogFormat?, log_group: tLogGroup?, system_log_level: tSystemLogLevel? }
      class LoggingConfig
        include Seahorse::Client::DelegatorMethodsForResponse[LoggingConfig]

        attr_accessor log_format: tLogFormat

        attr_accessor application_log_level: tApplicationLogLevel

        attr_accessor system_log_level: tSystemLogLevel

        attr_accessor log_group: tLogGroup
      end
      type tLong = ::Integer
      type tMasterRegion = ::String
      type tMaxAge = ::Integer
      type tMaxFunctionEventInvokeConfigListItems = ::Integer
      type tMaxItems = ::Integer
      type tMaxLayerListItems = ::Integer
      type tMaxListItems = ::Integer
      type tMaxProvisionedConcurrencyConfigListItems = ::Integer
      type tMaximumBatchingWindowInSeconds = ::Integer
      type tMaximumConcurrency = ::Integer
      type tMaximumEventAgeInSeconds = ::Integer
      type tMaximumRecordAgeInSeconds = ::Integer
      type tMaximumRetryAttempts = ::Integer
      type tMaximumRetryAttemptsEventSourceMapping = ::Integer
      type tMemorySize = ::Integer
      type tMethod = ::String
      type tNameSpacedFunctionArn = ::String
      type tNamespacedFunctionName = ::String
      type tNamespacedStatementId = ::String
      type tNonNegativeInteger = ::Integer
      type tNullableBoolean = bool
      type tOnFailure = { destination: tDestinationArn? }
      class OnFailure
        include Seahorse::Client::DelegatorMethodsForResponse[OnFailure]

        attr_accessor destination: tDestinationArn
      end
      type tOnSuccess = { destination: tDestinationArn? }
      class OnSuccess
        include Seahorse::Client::DelegatorMethodsForResponse[OnSuccess]

        attr_accessor destination: tDestinationArn
      end
      type tOrganizationId = ::String
      type tOrigin = ::String
      type tPackageType = ("Zip" | "Image")
      type tParallelizationFactor = ::Integer
      type tPattern = ::String
      type tPositiveInteger = ::Integer
      type tPrincipal = ::String
      type tPrincipalOrgID = ::String
      type tProvisionedConcurrencyConfigList = ::Array[ProvisionedConcurrencyConfigListItem]
      class ProvisionedConcurrencyConfigListItem
        include Seahorse::Client::DelegatorMethodsForResponse[ProvisionedConcurrencyConfigListItem]

        attr_accessor function_arn: tFunctionArn

        attr_accessor requested_provisioned_concurrent_executions: tPositiveInteger

        attr_accessor available_provisioned_concurrent_executions: tNonNegativeInteger

        attr_accessor allocated_provisioned_concurrent_executions: tNonNegativeInteger

        attr_accessor status: tProvisionedConcurrencyStatusEnum

        attr_accessor status_reason: tString

        attr_accessor last_modified: tTimestamp
      end
      type tProvisionedConcurrencyStatusEnum = ("IN_PROGRESS" | "READY" | "FAILED")
      type tPublishLayerVersionRequest = { content: tLayerVersionContentInput, layer_name: tLayerName, compatible_architectures: tCompatibleArchitectures?, compatible_runtimes: tCompatibleRuntimes?, description: tDescription?, license_info: tLicenseInfo? }
      class PublishLayerVersionResponse
        include Seahorse::Client::DelegatorMethodsForResponse[PublishLayerVersionResponse]

        attr_accessor content: LayerVersionContentOutput

        attr_accessor layer_arn: tLayerArn

        attr_accessor layer_version_arn: tLayerVersionArn

        attr_accessor description: tDescription

        attr_accessor created_date: tTimestamp

        attr_accessor version: tLayerVersionNumber

        attr_accessor compatible_runtimes: tCompatibleRuntimes

        attr_accessor license_info: tLicenseInfo

        attr_accessor compatible_architectures: tCompatibleArchitectures
      end
      type tPublishVersionRequest = { function_name: tFunctionName, code_sha_256: tString?, description: tDescription?, revision_id: tString? }
      type tPutFunctionCodeSigningConfigRequest = { code_signing_config_arn: tCodeSigningConfigArn, function_name: tFunctionName }
      class PutFunctionCodeSigningConfigResponse
        include Seahorse::Client::DelegatorMethodsForResponse[PutFunctionCodeSigningConfigResponse]

        attr_accessor code_signing_config_arn: tCodeSigningConfigArn

        attr_accessor function_name: tFunctionName
      end
      type tPutFunctionConcurrencyRequest = { function_name: tFunctionName, reserved_concurrent_executions: tReservedConcurrentExecutions }
      type tPutFunctionEventInvokeConfigRequest = { function_name: tFunctionName, destination_config: tDestinationConfig?, maximum_event_age_in_seconds: tMaximumEventAgeInSeconds?, maximum_retry_attempts: tMaximumRetryAttempts?, qualifier: tQualifier? }
      type tPutProvisionedConcurrencyConfigRequest = { function_name: tFunctionName, provisioned_concurrent_executions: tPositiveInteger, qualifier: tQualifier }
      class PutProvisionedConcurrencyConfigResponse
        include Seahorse::Client::DelegatorMethodsForResponse[PutProvisionedConcurrencyConfigResponse]

        attr_accessor requested_provisioned_concurrent_executions: tPositiveInteger

        attr_accessor available_provisioned_concurrent_executions: tNonNegativeInteger

        attr_accessor allocated_provisioned_concurrent_executions: tNonNegativeInteger

        attr_accessor status: tProvisionedConcurrencyStatusEnum

        attr_accessor status_reason: tString

        attr_accessor last_modified: tTimestamp
      end
      type tPutRuntimeManagementConfigRequest = { function_name: tFunctionName, update_runtime_on: tUpdateRuntimeOn, qualifier: tQualifier?, runtime_version_arn: tRuntimeVersionArn? }
      class PutRuntimeManagementConfigResponse
        include Seahorse::Client::DelegatorMethodsForResponse[PutRuntimeManagementConfigResponse]

        attr_accessor update_runtime_on: tUpdateRuntimeOn

        attr_accessor function_arn: tFunctionArn

        attr_accessor runtime_version_arn: tRuntimeVersionArn
      end
      type tQualifier = ::String
      type tQueue = ::String
      type tQueues = ::Array[tQueue]
      type tRemoveLayerVersionPermissionRequest = { layer_name: tLayerName, statement_id: tStatementId, version_number: tLayerVersionNumber, revision_id: tString? }
      type tRemovePermissionRequest = { function_name: tFunctionName, statement_id: tNamespacedStatementId, qualifier: tQualifier?, revision_id: tString? }
      type tReservedConcurrentExecutions = ::Integer
      type tResourceArn = ::String
      type tResponseStreamingInvocationType = ("RequestResponse" | "DryRun")
      type tRoleArn = ::String
      type tRuntime = ("nodejs" | "nodejs4.3" | "nodejs6.10" | "nodejs8.10" | "nodejs10.x" | "nodejs12.x" | "nodejs14.x" | "nodejs16.x" | "java8" | "java8.al2" | "java11" | "python2.7" | "python3.6" | "python3.7" | "python3.8" | "python3.9" | "dotnetcore1.0" | "dotnetcore2.0" | "dotnetcore2.1" | "dotnetcore3.1" | "dotnet6" | "nodejs4.3-edge" | "go1.x" | "ruby2.5" | "ruby2.7" | "provided" | "provided.al2" | "nodejs18.x" | "python3.10" | "java17" | "ruby3.2" | "python3.11" | "nodejs20.x" | "provided.al2023" | "python3.12" | "java21")
      type tRuntimeVersionArn = ::String
      class RuntimeVersionConfig
        include Seahorse::Client::DelegatorMethodsForResponse[RuntimeVersionConfig]

        attr_accessor runtime_version_arn: tRuntimeVersionArn

        attr_accessor error: RuntimeVersionError
      end
      class RuntimeVersionError
        include Seahorse::Client::DelegatorMethodsForResponse[RuntimeVersionError]

        attr_accessor error_code: tString

        attr_accessor message: tSensitiveString
      end
      type tS3Bucket = ::String
      type tS3Key = ::String
      type tS3ObjectVersion = ::String
      type tScalingConfig = { maximum_concurrency: tMaximumConcurrency? }
      class ScalingConfig
        include Seahorse::Client::DelegatorMethodsForResponse[ScalingConfig]

        attr_accessor maximum_concurrency: tMaximumConcurrency
      end
      type tSecurityGroupId = ::String
      type tSecurityGroupIds = ::Array[tSecurityGroupId]
      type tSelfManagedEventSource = { endpoints: tEndpoints? }
      class SelfManagedEventSource
        include Seahorse::Client::DelegatorMethodsForResponse[SelfManagedEventSource]

        attr_accessor endpoints: tEndpoints
      end
      type tSelfManagedKafkaEventSourceConfig = { consumer_group_id: tURI? }
      class SelfManagedKafkaEventSourceConfig
        include Seahorse::Client::DelegatorMethodsForResponse[SelfManagedKafkaEventSourceConfig]

        attr_accessor consumer_group_id: tURI
      end
      type tSensitiveString = ::String
      type tSigningProfileVersionArns = ::Array[tArn]
      type tSnapStart = { apply_on: tSnapStartApplyOn? }
      type tSnapStartApplyOn = ("PublishedVersions" | "None")
      type tSnapStartOptimizationStatus = ("On" | "Off")
      class SnapStartResponse
        include Seahorse::Client::DelegatorMethodsForResponse[SnapStartResponse]

        attr_accessor apply_on: tSnapStartApplyOn

        attr_accessor optimization_status: tSnapStartOptimizationStatus
      end
      type tSourceAccessConfiguration = { type: tSourceAccessType?, uri: tURI? }
      class SourceAccessConfiguration
        include Seahorse::Client::DelegatorMethodsForResponse[SourceAccessConfiguration]

        attr_accessor type: tSourceAccessType

        attr_accessor uri: tURI
      end
      type tSourceAccessConfigurations_input = ::Array[tSourceAccessConfiguration]
      type tSourceAccessConfigurations_output = ::Array[SourceAccessConfiguration]
      type tSourceAccessType = ("BASIC_AUTH" | "VPC_SUBNET" | "VPC_SECURITY_GROUP" | "SASL_SCRAM_512_AUTH" | "SASL_SCRAM_256_AUTH" | "VIRTUAL_HOST" | "CLIENT_CERTIFICATE_TLS_AUTH" | "SERVER_ROOT_CA_CERTIFICATE")
      type tSourceOwner = ::String
      type tState = ("Pending" | "Active" | "Inactive" | "Failed")
      type tStateReason = ::String
      type tStateReasonCode = ("Idle" | "Creating" | "Restoring" | "EniLimitExceeded" | "InsufficientRolePermissions" | "InvalidConfiguration" | "InternalError" | "SubnetOutOfIPAddresses" | "InvalidSubnet" | "InvalidSecurityGroup" | "ImageDeleted" | "ImageAccessDenied" | "InvalidImage" | "KMSKeyAccessDenied" | "KMSKeyNotFound" | "InvalidStateKMSKey" | "DisabledKMSKey" | "EFSIOError" | "EFSMountConnectivityError" | "EFSMountFailure" | "EFSMountTimeout" | "InvalidRuntime" | "InvalidZipFileException" | "FunctionError")
      type tStatementId = ::String
      type tString = ::String
      type tStringList = ::Array[tString]
      type tSubnetId = ::String
      type tSubnetIds = ::Array[tSubnetId]
      type tSystemLogLevel = ("DEBUG" | "INFO" | "WARN")
      type tTagKey = ::String
      type tTagKeyList = ::Array[tTagKey]
      type tTagResourceRequest = { resource: tFunctionArn, tags: tTags }
      type tTagValue = ::String
      type tTags = ::Hash[tTagKey, tTagValue]
      type tThrottleReason = ("ConcurrentInvocationLimitExceeded" | "FunctionInvocationRateLimitExceeded" | "ReservedFunctionConcurrentInvocationLimitExceeded" | "ReservedFunctionInvocationRateLimitExceeded" | "CallerRateLimitExceeded" | "ConcurrentSnapshotCreateLimitExceeded")
      type tTimeout = ::Integer
      type tTimestamp = ::Time
      type tTopic = ::String
      type tTopics = ::Array[tTopic]
      type tTracingConfig = { mode: tTracingMode? }
      class TracingConfigResponse
        include Seahorse::Client::DelegatorMethodsForResponse[TracingConfigResponse]

        attr_accessor mode: tTracingMode
      end
      type tTracingMode = ("Active" | "PassThrough")
      type tTumblingWindowInSeconds = ::Integer
      type tURI = ::String
      type tUnreservedConcurrentExecutions = ::Integer
      type tUntagResourceRequest = { resource: tFunctionArn, tag_keys: tTagKeyList }
      type tUpdateAliasRequest = { function_name: tFunctionName, name: tAlias, description: tDescription?, function_version: tVersion?, revision_id: tString?, routing_config: tAliasRoutingConfiguration? }
      type tUpdateCodeSigningConfigRequest = { code_signing_config_arn: tCodeSigningConfigArn, allowed_publishers: tAllowedPublishers?, code_signing_policies: tCodeSigningPolicies?, description: tDescription? }
      class UpdateCodeSigningConfigResponse
        include Seahorse::Client::DelegatorMethodsForResponse[UpdateCodeSigningConfigResponse]

        attr_accessor code_signing_config: CodeSigningConfig
      end
      type tUpdateEventSourceMappingRequest = { uuid: tString, batch_size: tBatchSize?, bisect_batch_on_function_error: tBisectBatchOnFunctionError?, destination_config: tDestinationConfig?, document_db_event_source_config: tDocumentDBEventSourceConfig?, enabled: tEnabled?, filter_criteria: tFilterCriteria?, function_name: tFunctionName?, function_response_types: tFunctionResponseTypeList?, maximum_batching_window_in_seconds: tMaximumBatchingWindowInSeconds?, maximum_record_age_in_seconds: tMaximumRecordAgeInSeconds?, maximum_retry_attempts: tMaximumRetryAttemptsEventSourceMapping?, parallelization_factor: tParallelizationFactor?, scaling_config: tScalingConfig?, source_access_configurations: tSourceAccessConfigurations_input?, tumbling_window_in_seconds: tTumblingWindowInSeconds? }
      type tUpdateFunctionCodeRequest = { function_name: tFunctionName, architectures: tArchitecturesList?, dry_run: tBoolean?, image_uri: tString?, publish: tBoolean?, revision_id: tString?, s3_bucket: tS3Bucket?, s3_key: tS3Key?, s3_object_version: tS3ObjectVersion?, zip_file: tBlob? }
      type tUpdateFunctionConfigurationRequest = { function_name: tFunctionName, dead_letter_config: tDeadLetterConfig?, description: tDescription?, environment: tEnvironment?, ephemeral_storage: tEphemeralStorage?, file_system_configs: tFileSystemConfigList_input?, handler: tHandler?, image_config: tImageConfig?, kms_key_arn: tKMSKeyArn?, layers: tLayerList?, logging_config: tLoggingConfig?, memory_size: tMemorySize?, revision_id: tString?, role: tRoleArn?, runtime: tRuntime?, snap_start: tSnapStart?, timeout: tTimeout?, tracing_config: tTracingConfig?, vpc_config: tVpcConfig? }
      type tUpdateFunctionEventInvokeConfigRequest = { function_name: tFunctionName, destination_config: tDestinationConfig?, maximum_event_age_in_seconds: tMaximumEventAgeInSeconds?, maximum_retry_attempts: tMaximumRetryAttempts?, qualifier: tQualifier? }
      type tUpdateFunctionUrlConfigRequest = { function_name: tFunctionName, auth_type: tFunctionUrlAuthType?, cors: tCors?, invoke_mode: tInvokeMode?, qualifier: tFunctionUrlQualifier? }
      class UpdateFunctionUrlConfigResponse
        include Seahorse::Client::DelegatorMethodsForResponse[UpdateFunctionUrlConfigResponse]

        attr_accessor function_url: tFunctionUrl

        attr_accessor function_arn: tFunctionArn

        attr_accessor auth_type: tFunctionUrlAuthType

        attr_accessor cors: Cors

        attr_accessor creation_time: tTimestamp

        attr_accessor last_modified_time: tTimestamp

        attr_accessor invoke_mode: tInvokeMode
      end
      type tUpdateRuntimeOn = ("Auto" | "Manual" | "FunctionUpdate")
      type tVersion = ::String
      type tVpcConfig = { ipv_6_allowed_for_dual_stack: tNullableBoolean?, security_group_ids: tSecurityGroupIds?, subnet_ids: tSubnetIds? }
      class VpcConfigResponse
        include Seahorse::Client::DelegatorMethodsForResponse[VpcConfigResponse]

        attr_accessor subnet_ids: tSubnetIds

        attr_accessor security_group_ids: tSecurityGroupIds

        attr_accessor vpc_id: tVpcId

        attr_accessor ipv_6_allowed_for_dual_stack: tNullableBoolean
      end
      type tVpcId = ::String
      type tWeight = ::Float
      type tWorkingDirectory = ::String
    end
  end
end
